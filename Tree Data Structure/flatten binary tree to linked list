/*       1
        / \
       2   5
      / \   \
     3   4   6*/

TreeNode* PREV=NULL;
void solve(TreeNode* root){
    if(!root)
        return;
    solve(root->right);
    solve(root->left);
    root->left=NULL;
    root->right=PREV;
    PREV=root;
}
TreeNode* Solution::flatten(TreeNode* A) {
    if(!A) return NULL;
    PREV=NULL;
    solve(A);
    return PREV;
}


or



TreeNode* Solution::flatten(TreeNode* root) {
	while (root)
	{
		if(root->left)
		{
            //Find current node's prenode that links to current node's right subtree
			TreeNode* pre = root->left;
			while(pre->right)
			{
				pre = pre->right;
			}
			pre->right = root->right;
            //Use current node's left subtree to replace its right subtree(original right 
            //subtree is already linked by current node's prenode
			root->right = root->left;
			root->left = NULL;
		}
		root = root->right;
	}
    
}
