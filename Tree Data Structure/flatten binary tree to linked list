/*       1
        / \
       2   5
      / \   \
     3   4   6*/

TreeNode* PREV=NULL;
void solve(TreeNode* root){
    if(!root)
        return;
    solve(root->right);
    solve(root->left);
    root->left=NULL;
    root->right=PREV;
    PREV=root;
}
TreeNode* Solution::flatten(TreeNode* A) {
    if(!A) return NULL;
    PREV=NULL;
    solve(A);
    return PREV;
}


or



class Solution {
public:
    void flatten(TreeNode *root) {
		TreeNode*now = root;
		while (now)
		{
			if(now->left)
			{
                //Find current node's prenode that links to current node's right subtree
				TreeNode* pre = now->left;
				while(pre->right)
				{
					pre = pre->right;
				}
				pre->right = now->right;
                //Use current node's left subtree to replace its right subtree(original right 
                //subtree is already linked by current node's prenode
				now->right = now->left;
				now->left = NULL;
			}
			now = now->right;
		}
    }
};
